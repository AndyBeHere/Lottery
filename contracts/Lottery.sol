/**
 *Submitted for DeepGo on 2021-07-17
*/

//sol Lottery
// Lottery application: betting Dai in pool and winner is selected by random number requested from Chainlink
// @authors:
// Andrew <github.com/AndyBeHere>
// usage:
// todo
//
// info related to token used in this contract in Kovan testnet:
// get Chainlink VRF Contract information from https://docs.chain.link/docs/vrf-contracts/
// LINK	0xa36085F69e2889c224210F603D836748e7dC0088; decimal 18
// VRF Coordinator	0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9
// Key Hash	0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4
// Fee	0.1 LINK
// Dai 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa; decimal 18
pragma solidity ^0.6.6;

import "../node_modules/@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";
import "../node_modules/@chainlink/contracts/src/v0.6/VRFConsumerBase.sol";
import "../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../node_modules/@openzeppelin/contracts/access/Ownable.sol";

// invoke interface: IERC20(tokenMapping[_ticker].tokenAddress).balanceOf(msg.sender)
// -> IERC20(daiAddress).transfer(address(this), oneBet)

contract Lottery is VRFConsumerBase, Ownable {
    using SafeMathChainlink for uint;

    enum LotteryState {OPEN, CLOSED, CALCULATING_WINNER}

    address private admin;
    address private currentPlayer;
    address public daiAddress;
    address[] public recentWinners;
    uint256 public recentWinNumber;
    uint256 public oneBet;
    uint256 public rewardRate;
    uint256 public linkFee;
    uint256 public randomnessGet;
    uint256 public drawStartTime;
    // bet time interval and draw time interval 
    uint256 public timeInterval;
    uint testNumber;
    // saving random number generated by players (reset to 0 when lottery is closing)
    uint[] public randomNumbers;
    address[] public players;
    bytes32 public keyHash;
    LotteryState public lotteryState;
    // mapping random number to list of player address (can be repetitive)
    mapping(uint256 => address[]) public numberToPlayers;

    event RequestRandomness(bytes32 requestId);
    event Randomness(uint randomnessGet, uint randomness);

    constructor(address _dai, address _vrfCoordinator, address _link, bytes32 _keyhash) public
        VRFConsumerBase(
            _vrfCoordinator,
            _link
        ) {
        admin = msg.sender;
        daiAddress = _dai;
        oneBet = 5 * 10 ** 18;
        rewardRate = 80;
        linkFee = 10 ** 17;
        timeInterval = 5 minutes;
        lotteryState = LotteryState.CLOSED;
        keyHash = _keyhash;
    }

    // for test
    function setTestNumber() public {
        testNumber = now;
    }

    // for test
    function getTime() public view returns(uint) {
        return now;
    }

    function getPlayers() public view returns(address[] memory) {
        return players;
    }

    function getRecentWinners() public view returns(address[] memory) {
        return recentWinners;
    }

    function getRecentWinNumber() public view returns(uint) {
        return recentWinNumber;
    } 

    function startLottery() public onlyOwner {
        require(lotteryState == LotteryState.CLOSED, "start fail: lottery not closed!");
        lotteryState = LotteryState.OPEN;
        drawStartTime = now + timeInterval;
        randomnessGet = 0;
    }

    function enter() public {
        // Dai token sent >= oneBet; 
        require(lotteryState == LotteryState.OPEN, "enter fail: lottery not open!");
        require(now <= drawStartTime, "enter error: lottery ended!");
        require(IERC20(daiAddress).balanceOf(msg.sender) >= oneBet, "enter fail: Dai insufficient!");

        // update state
        currentPlayer = msg.sender;

        // pay for bet
        IERC20(daiAddress).transferFrom(msg.sender, address(this), oneBet);

        // generate random number
        getRandomNumber();
    }

    /** 
     * @dev end lottery: if there is Dai in pool then send bonus to winner and withdraw fee to admin
     */
    function endLottery() public onlyOwner {
        require(lotteryState == LotteryState.OPEN, "end fail: lottery not open!");
        require(now > drawStartTime && now - drawStartTime <= timeInterval, "end fail: invalid time");
        // update state
        lotteryState = LotteryState.CALCULATING_WINNER;
        getRandomNumber();
    }

    // function refund() public onlyOwner {
    //     _refund();
    // }

    function refund() public onlyOwner {
        // require(msg.sender == admin);
        require(lotteryState == LotteryState.OPEN, "refund fail: lottery not open!");
        require(players.length > 0, "refund error: no player!");
        require(now - drawStartTime > timeInterval, "refund fail: invalid time");

        for (uint i = 0; i < players.length; i++) {
            IERC20(daiAddress).transfer(players[i], oneBet);
            numberToPlayers[randomNumbers[i]] = new address[](0x0);
        }

        lotteryState = LotteryState.CLOSED; 
        randomNumbers = new uint[](0);
        players = new address[](0x0);
    }

    function getRandomNumber() private returns(bytes32) {
        require(lotteryState != LotteryState.CLOSED, "randomness fail: lottery closed!");
        bytes32 requestId = requestRandomness(keyHash, linkFee); 
        emit RequestRandomness(requestId);
        return requestId;
    }

  /**
   * @notice fulfillRandomness handles the VRF response. This contract implement
   * @notice it and override base one. It is called by VRFCoordinator.
   *
   * @dev VRFConsumerBase expects its subcontracts to have a method with this
   * @dev signature, and will call it once it has verified the proof
   * @dev associated with the randomness. (It is triggered via a call to
   * @dev rawFulfillRandomness, below.)
   *
   * @param requestId The Id initially returned by requestRandomness
   * @param randomness the VRF output
   * 
   * Tips: Base functions can be overridden by inheriting contracts to change 
   * their behavior if they are marked as virtual. The overriding function must 
   * then use the override  keyword in the function header
   */
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        // check if local randomness received override state variable 
        require(randomness > 0, "random number not found");
        randomnessGet = randomness;
        emit Randomness(randomnessGet, randomness);

        if (lotteryState == LotteryState.OPEN) {
            uint256 randomNumber = randomnessGet % 9999 + 1; // 1 ~ 9999

            // update state;
            randomNumbers.push(randomNumber);
            numberToPlayers[randomNumber].push(currentPlayer);
            players.push(currentPlayer);
            currentPlayer = address(0x0);
        } else {
            require(players.length > 0, "error: no player!");

            // select winners randomly
            uint256 randomIndex = randomnessGet % randomNumbers.length;
            recentWinNumber = randomNumbers[randomIndex];
            recentWinners = numberToPlayers[recentWinNumber];
            
            // update state
            for (uint256 i = 0; i < randomNumbers.length; i++) {
                numberToPlayers[randomNumbers[i]] = new address[](0x0);
            }

            lotteryState = LotteryState.CLOSED; 
            randomNumbers = new uint[](0);
            players = new address[](0x0);

            // transfer to winner and admin
            uint256 bonus = IERC20(daiAddress).balanceOf(address(this)) * rewardRate / 100 / recentWinners.length;

            for (uint256 i = 0; i < recentWinners.length; i++) {
                IERC20(daiAddress).transfer(recentWinners[i], bonus);
            }
            IERC20(daiAddress).transfer(admin, IERC20(daiAddress).balanceOf(address(this)));
        }
    }

}
